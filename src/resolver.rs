//! # MON Semantic Analyzer (Resolver)
//!
//! This module is responsible for the semantic analysis phase of the MON compilation pipeline.
//! The [`Resolver`] traverses the Abstract Syntax Tree (AST) generated by the [`Parser`](crate::parser::Parser)
//! and enriches it with semantic meaning.
//!
//! ## Architectural Overview
//!
//! The resolver is a stateful visitor that walks the AST and performs several key actions:
//! 
//! - **Import Resolution**: It finds, parses, and resolves `import` statements. It maintains a cache of
//!   already resolved documents to avoid redundant work and uses a resolving stack to detect circular
//!   dependencies between files. It also handles the `mon:` URI scheme for built-in schemas.
//! 
//! - **Symbol & Anchor Collection**: It populates a global symbol table with type definitions (`#struct`, `#enum`)
//!   and a global map with all declared anchors (`&my_anchor`).
//! 
//! - **Alias and Spread Resolution**: It replaces all aliases (`*my_anchor`) and spreads (`...*my_anchor`)
//!   with deep clones of their original values. This is where composition happens.
//! 
//! - **Validation**: It performs type checking for any pair that has a validation specifier (`:: MyType`).
//!   It ensures that structs have the correct fields, enums have valid variants, and that all types match
//!   their definitions.
//! 
//! After the resolver has finished, the AST is considered fully resolved and validated.
//! 
//! ## Use Cases
//! 
//! While you can use the resolver directly for fine-grained control, most users will interact
//! with it via the top-level [`analyze`](crate::api::analyze) function. Direct use is beneficial when:
//! 
//! - You need to inspect the symbol table or anchors after resolution.
//! - You want to provide a custom path for built-in schemas.
//! - You are building a tool that needs to hook into a specific part of the analysis lifecycle.
//! 
//! ## Example: Direct Resolver Usage
//! 
//! ```rust
//! use mon_core::parser::Parser;
//! use mon_core::resolver::Resolver;
//! use mon_core::error::MonError;
//! use std::path::PathBuf;
//! 
//! # fn main() -> Result<(), MonError> {
//! let source = r#"
//! {
//!     MyStruct: #struct { name(String) },
//!     &my_data: { name: "Hello" },
//! 
//!     // This instance will be validated against MyStruct.
//!     instance :: MyStruct = *my_data
//! }
//! "#;
//! let file_path = PathBuf::from("my_file.mon");
//! 
//! // 1. The resolver needs a parsed document from the parser.
//! let mut parser = Parser::new_with_name(source, file_path.to_string_lossy().to_string())?;
//! let document = parser.parse_document()?;
//! 
//! // 2. Create and run the resolver.
//! let mut resolver = Resolver::new();
//! let resolved_document = resolver.resolve(document.clone(), source, file_path, None)?;
//! 
//! // 3. Inspect the results.
//! assert!(resolver.symbol_table.types.contains_key("MyStruct"));
//! assert!(resolver.anchors.contains_key("my_data"));
//! # Ok(())
//! # }
//! ```
use crate::ast::{
    ImportSpec, ImportStatement, Member, MonDocument, MonValue, MonValueKind,
    SymbolTable as AstSymbolTable, TypeDef, TypeSpec,
};
use crate::error::{ResolverError, ValidationError};
use log::warn;
use miette::NamedSource;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;

/// Traverses a [`MonDocument`] to resolve imports, aliases, and spreads, and to validate data against schemas.
///
/// The `Resolver` is responsible for the semantic analysis of a parsed MON document from the [`Parser`].
/// It is a crucial step that transforms a syntactically correct document into a fully validated and
/// usable data structure.
///
/// It performs several key tasks:
/// - **Import Resolution**: It parses and resolves `import` statements, loading symbols from other files
///   and handling `mon:` URIs for built-in schemas. It also detects circular dependencies.
/// - **Symbol Collection**: It gathers all type definitions (like structs and enums) and anchors
///   into a global [`AstSymbolTable`].
/// - **Alias & Spread Resolution**: It replaces aliases (e.g., `*my_anchor`) and spreads (e.g., `...*my_anchor`)
///   with their corresponding values, effectively performing composition.
/// - **Validation**: It validates data against declared types using the `::` operator (e.g.,
///   `my_field :: MyType = ...`), ensuring type safety and data integrity. This includes checking
///   for missing/extra fields in structs and validating collection types.
///
/// # Example: How to use the Resolver
///
/// While the main public entry point is the [`analyze`](crate::api::analyze) function, you can use
/// the `Resolver` directly if you need more control over the process, such as inspecting the
/// symbol table or using a custom built-in schema path.
///
/// ```rust
/// use mon_core::parser::Parser;
/// use mon_core::resolver::Resolver;
/// use mon_core::error::MonError;
/// use std::path::PathBuf;
///
/// # fn main() -> Result<(), MonError> {
/// let source = r###"
/// {
///     MyStruct: #struct { name(String) },
///     &my_data: { name: "Hello" },
/// 
///     // This instance will be validated against MyStruct.
///     instance :: MyStruct = *my_data
/// }
/// "###;
/// let file_path = PathBuf::from("my_file.mon");
///
/// // 1. The resolver needs a parsed document to work with.
/// let mut parser = Parser::new_with_name(source, file_path.to_string_lossy().to_string())?;
/// let document = parser.parse_document()?;
///
/// // 2. Create a new resolver.
/// let mut resolver = Resolver::new();
///
/// // 3. Resolve the document. This returns the final, validated document.
/// let resolved_document = resolver.resolve(document.clone(), source, file_path, None)?;
///
/// // You can now access the resolved data, symbol table, and anchors.
/// assert!(resolver.symbol_table.types.contains_key("MyStruct"));
/// assert!(resolver.anchors.contains_key("my_data"));
///
/// # Ok(())
/// # }
/// ```
pub struct Resolver {
    // Stores resolved documents by their absolute path
    resolved_documents: HashMap<PathBuf, MonDocument>,
    // Stack to detect circular dependencies during import resolution
    resolving_stack: Vec<(PathBuf, Option<ImportStatement>) >,
    // Global symbol table for types
    pub symbol_table: AstSymbolTable,
    // Global map for anchors
    pub anchors: HashMap<String, MonValue>,

    builtin_schemas_path: PathBuf,
}

impl Resolver {
    /// Creates a new `Resolver` with a default search path for built-in schemas.
    ///
    /// The default path is determined by [`Resolver::default_builtin_path`].
    #[must_use]
    pub fn new() -> Self {
        Self::with_builtin_path(Self::default_builtin_path())
    }

    /// Creates a new `Resolver` with a custom search path for built-in schemas.
    ///
    /// This is useful for testing or for applications that bundle their own schemas.
    pub fn with_builtin_path(path: PathBuf) -> Self {
        Resolver {
            resolved_documents: HashMap::new(),
            resolving_stack: Vec::new(),
            symbol_table: AstSymbolTable::new(),
            anchors: HashMap::new(),
            builtin_schemas_path: path,
        }
    }

    /// Determines the default path for built-in schemas, used for resolving `mon:` URIs.
    ///
    /// The lookup order is as follows:
    /// 1. The `MON_BUILTIN_PATH` environment variable.
    /// 2. The `.mon/schemas` directory in the user's home directory.
    /// 3. The system-wide path `/usr/share/mon/schemas` (on Unix-like systems).
    /// 4. Fallback to the current working directory (a warning will be logged).
    fn default_builtin_path() -> PathBuf {
        // Try these in order:
        // 1. Environment variable
        if let Ok(path) = std::env::var("MON_BUILTIN_PATH") {
            return PathBuf::from(path);
        }

        // 2. User home directory
        if let Some(home) = std::env::var_os("HOME") {
            let user_schemas = PathBuf::from(home).join(".mon/schemas");
            if user_schemas.exists() {
                return user_schemas;
            }
        }

        // 3. System-wide (Linux/Mac)
        #[cfg(unix)]
        {
            let system_path = PathBuf::from("/usr/share/mon/schemas");
            if system_path.exists() {
                return system_path;
            }
        }

        // 4. Fallback to current directory
        warn!(
            "Could not determine default schemas path, defaulting to current directory.
        This is probably not intended"
        );
        PathBuf::from(".")
    }

    /// Resolves an import path string into an absolute `PathBuf`.
    ///
    /// This handles two types of paths:
    /// - **mon-URIs**: Paths starting with `mon:` are resolved relative to the `builtin_schemas_path`.
    ///   For example, `mon:types/linter` becomes `{builtin_schemas_path}/types/linter.mon`.
    /// - **File Paths**: Relative paths are joined with the `current_dir`. Absolute paths are used as is.
    fn resolve_import_path(&self, import_path: &str, current_dir: &Path) -> PathBuf {
        // Handle mon: URI
        if let Some(builtin_path) = import_path.strip_prefix("mon:") {
            // "mon:types/linter" â†’ "{builtin_schemas_path}/types/linter.mon"
            return self
                .builtin_schemas_path
                .join(builtin_path)
                .with_extension("mon");
        }

        // Handle relative/absolute paths normally
        current_dir.join(import_path)
    }
    /// Recursively resolves a [`MonDocument`].
    ///
    /// This is the main entry point for the resolver's logic. It takes a parsed document
    /// and performs the full semantic analysis lifecycle.
    ///
    /// # Arguments
    ///
    /// * `document`: The parsed [`MonDocument`] to resolve.
    /// * `source_text`: The original source code string, used for error reporting.
    /// * `file_path`: The absolute path to the file being resolved, used for resolving relative imports.
    /// * `causing_import`: An optional [`ImportStatement`] that triggered the resolution of this file,
    ///   used for circular dependency tracking.
    ///
    /// # Errors
    ///
    /// This function can return a [`ResolverError`] if any of the following occurs:
    /// - A module specified in an `import` statement cannot be found ([`ResolverError::ModuleNotFound`]).
    /// - A circular dependency is detected between imported modules ([`ResolverError::CircularDependency`]).
    /// - An anchor, alias, or spread is used incorrectly.
    /// - A validation error occurs when checking data against a schema ([`ResolverError::Validation`]).
    /// - A parsing error occurs in an imported file.
    pub fn resolve(
        &mut self,
        document: MonDocument,
        source_text: &str,
        file_path: PathBuf,
        causing_import: Option<ImportStatement>,
    ) -> Result<MonDocument, ResolverError> {
        // Add the current file to the resolving stack to detect cycles
        if let Some((_, Some(existing_causing_import))) =
            self.resolving_stack.iter().find(|(p, _)| p == &file_path)
        {
            let cycle_str = self
                .resolving_stack
                .iter()
                .map(|(p, _)| p.to_string_lossy().to_string())
                .collect::<Vec<String>>()
                .join(" -> ");
            return Err(ResolverError::CircularDependency {
                cycle: format!("{} -> {}", cycle_str, file_path.to_string_lossy()),
                src: NamedSource::new(file_path.to_string_lossy(), source_text.to_string()).into(),
                span: (
                    existing_causing_import.pos_start,
                    existing_causing_import.pos_end - existing_causing_import.pos_start,
                )
                    .into(),
            });
        }
        self.resolving_stack
            .push((file_path.clone(), causing_import)); // Push with the provided causing_import

        // 1. Process imports
        let current_dir = file_path.parent().unwrap_or_else(|| Path::new("."));
        let source_arc = Arc::new(source_text.to_string());
        for import_statement in &document.imports {
            let imported_path_str = import_statement.path.trim_matches('"');

            // for mon: ...
            let absolute_imported_path = self.resolve_import_path(imported_path_str, current_dir);
            if self
                .resolved_documents
                .contains_key(&absolute_imported_path)
            {
                continue;
            }
            let imported_source_text = 
                std::fs::read_to_string(&absolute_imported_path).map_err(|_|
                    ResolverError::ModuleNotFound {
                        path: imported_path_str.to_string(),
                        src: Arc::from(NamedSource::new(
                            file_path.to_string_lossy(),
                            source_arc.to_string(),
                        )),
                        span: (
                            import_statement.pos_start,
                            import_statement.pos_end - import_statement.pos_start,
                        )
                            .into(),
                    }
                )?;
            // Parse without std_path - parser doesn't need it!
            let mut parser = crate::parser::Parser::new_with_name(
                &imported_source_text,
                absolute_imported_path.to_string_lossy().to_string(),
            )?;

            let imported_document = parser.parse_document()?;
            let resolved_imported_document = self.resolve(
                imported_document,
                &imported_source_text,
                absolute_imported_path.clone(),
                Some(import_statement.clone()),
            )?;
            self.resolved_documents
                .insert(absolute_imported_path, resolved_imported_document);
        }

        // After resolving all imports, process named imports to populate the symbol table
        for import_statement in &document.imports {
            if let ImportSpec::Named(specifiers) = &import_statement.spec {
                let imported_path_str = import_statement.path.trim_matches('"');
                let absolute_imported_path = current_dir.join(imported_path_str);
                if let Some(imported_doc) = self.resolved_documents.get(&absolute_imported_path) {
                    if let MonValueKind::Object(members) = &imported_doc.root.kind {
                        for specifier in specifiers {
                            if !specifier.is_anchor {
                                for member in members {
                                    if let Member::TypeDefinition(td) = member {
                                        if td.name == specifier.name {
                                            self.symbol_table
                                                .types
                                                .insert(specifier.name.clone(), td.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // 2. Collect type definitions and anchors from the current document
        if let MonValueKind::Object(members) = &document.root.kind {
            for member in members {
                match member {
                    Member::TypeDefinition(type_def) => {
                        self.symbol_table
                            .types
                            .insert(type_def.name.clone(), type_def.clone());
                    }
                    Member::Pair(pair) => {
                        if let Some(anchor_name) = &pair.value.anchor {
                            self.anchors.insert(anchor_name.clone(), pair.value.clone());
                        }
                    }
                    _ => {}
                }
            }
        }

        // 3. Resolve aliases and spreads
        let resolved_root = self.resolve_value(document.root, &file_path, source_text)?;

        // 4. Validate the resolved document
        // This will involve iterating through the resolved_root and applying validations
        // where `:: Type` is specified.
        let final_resolved_root =
            self.validate_document_root(resolved_root, &document.imports, &file_path, source_text)?;

        let resolved_doc = MonDocument {
            root: final_resolved_root,
            imports: document.imports, // Imports are already processed
        };

        // Remove the current file from the stack
        self.resolving_stack.pop();

        Ok(resolved_doc)
    }
    // Helper function to recursively resolve aliases and spreads within a MonValue
    /// Recursively resolves aliases and spreads within a [`MonValue`].
    fn resolve_value(
        &mut self,
        mut value: MonValue,
        file_path: &PathBuf,
        source_text: &str,
    ) -> Result<MonValue, ResolverError> {
        let alias_span = value.get_source_span();

        match &mut value.kind {
            MonValueKind::Alias(alias_name) => {
                // Resolve alias: find the anchored value and return a deep copy
                let anchor_value = self.anchors.get(alias_name).ok_or_else(|| {
                    // TODO: Get actual span for the alias
                    ResolverError::AnchorNotFound {
                        name: alias_name.clone(),
                        src: Arc::from(NamedSource::new(
                            file_path.to_string_lossy(),
                            source_text.to_string(),
                        )),
                        span: alias_span,
                    }
                })?;
                Ok(anchor_value.clone()) // Return a deep copy
            }
            MonValueKind::Object(members) => {
                let mut resolved_members = Vec::new();
                for member in members.drain(..) {
                    match member {
                        Member::Spread(spread_name) => {
                            // Resolve object spread: merge members from anchored object
                            let anchor_value = self.anchors.get(&spread_name).ok_or_else(|| {
                                // TODO: Get actual span for the spread
                                ResolverError::AnchorNotFound {
                                    name: spread_name.clone(),
                                    src: Arc::from(NamedSource::new(
                                        file_path.to_string_lossy(),
                                        source_text.to_string(),
                                    )),
                                    span: alias_span,
                                }
                            })?;
                            if let MonValueKind::Object(spread_members) = &anchor_value.kind {
                                let spread_members_clone = spread_members.clone();
                                for spread_member in spread_members_clone {
                                    // Recursively resolve spread members
                                    resolved_members.push(self.resolve_value_member(
                                        spread_member,
                                        file_path,
                                        source_text,
                                    )?);
                                }
                            } else {
                                return Err(ResolverError::SpreadOnNonObject {
                                    name: spread_name.clone(),
                                    src: Arc::from(NamedSource::new(
                                        file_path.to_string_lossy(),
                                        source_text.to_string(),
                                    )),
                                    span: alias_span,
                                });
                            }
                        }
                        _ => {
                            // Recursively resolve other members
                            resolved_members.push(self.resolve_value_member(
                                member,
                                file_path,
                                source_text,
                            )?);
                        }
                    }
                }
                // Handle key overriding for object spreads (local keys win)
                let mut final_members_map: HashMap<String, Member> = HashMap::new();
                for member in resolved_members {
                    if let Member::Pair(pair) = member {
                        final_members_map.insert(pair.key.clone(), Member::Pair(pair));
                    } else {
                        // Non-pair members (like TypeDefinition) are just added
                        // This might need refinement depending on how TypeDefinitions are handled after resolution
                        final_members_map.insert(format!("{member:?}"), member); // Dummy key for now
                    }
                }
                let final_members = final_members_map.into_values().collect();
                Ok(MonValue {
                    kind: MonValueKind::Object(final_members),
                    anchor: value.anchor,
                    pos_start: value.pos_start,
                    pos_end: value.pos_end,
                })
            }
            MonValueKind::Array(elements) => {
                let mut resolved_elements = Vec::new();
                for element in elements.drain(..) {
                    match element.kind {
                        MonValueKind::ArraySpread(spread_name) => {
                            // Resolve array spread: concatenate elements from anchored array
                            let anchor_value = self.anchors.get(&spread_name).ok_or_else(|| {
                                // TODO: Get actual span for the spread
                                ResolverError::AnchorNotFound {
                                    name: spread_name.clone(),
                                    src: Arc::from(NamedSource::new(
                                        file_path.to_string_lossy(),
                                        source_text.to_string(),
                                    )),
                                    span: alias_span,
                                }
                            })?;
                            if let MonValueKind::Array(spread_elements) = &anchor_value.kind {
                                let spread_elements_clone = spread_elements.clone();
                                for spread_element in spread_elements_clone {
                                    // Recursively resolve spread elements
                                    resolved_elements.push(self.resolve_value(
                                        spread_element,
                                        file_path,
                                        source_text,
                                    )?);
                                }
                            } else {
                                // TODO: Get actual span for the spread
                                return Err(ResolverError::SpreadOnNonArray {
                                    name: spread_name.clone(),
                                    src: Arc::from(NamedSource::new(
                                        file_path.to_string_lossy(),
                                        source_text.to_string(),
                                    )),
                                    span: alias_span,
                                });
                            }
                        }
                        _ => {
                            // Recursively resolve other elements
                            resolved_elements.push(self.resolve_value(
                                element,
                                file_path,
                                source_text,
                            )?);
                        }
                    }
                }
                Ok(MonValue {
                    kind: MonValueKind::Array(resolved_elements),
                    anchor: value.anchor,
                    pos_start: value.pos_start,
                    pos_end: value.pos_end,
                })
            }
            _ => Ok(value), // Other literal values don't need further resolution
        }
    }

    /// Helper to resolve a [`Member`] within a value.
    fn resolve_value_member(
        &mut self,
        mut member: Member,
        file_path: &PathBuf,
        source_text: &str,
    ) -> Result<Member, ResolverError> {
        match &mut member {
            Member::Pair(pair) => {
                pair.value = self.resolve_value(pair.value.clone(), file_path, source_text)?;
                Ok(member)
            }
            // Type definitions and imports are already processed or don't need further resolution here
            _ => Ok(member),
        }
    }

    /// Kicks off the validation process for the document's root value.
    fn validate_document_root(
        &mut self,
        mut root_value: MonValue,
        imports: &[ImportStatement], // Change this parameter
        file_path: &PathBuf,
        source_text: &str,
    ) -> Result<MonValue, ResolverError> {
        if let MonValueKind::Object(members) = &mut root_value.kind {
            for member in members.iter_mut() {
                if let Member::Pair(pair) = member {
                    if let Some(type_spec) = &pair.validation {
                        // Perform validation for this pair
                        self.validate_value(
                            &mut pair.value,
                            type_spec,
                            &pair.key,
                            imports, // Pass the imports here
                            file_path,
                            source_text,
                        )?;
                    }
                }
            }
        }
        Ok(root_value)
    }

    /// Recursively validates a [`MonValue`] against a [`TypeSpec`].
    fn validate_value(
        &mut self,
        value: &mut MonValue,
        type_spec: &TypeSpec,
        field_name: &str,            // For error reporting
        imports: &[ImportStatement], // Change this parameter
        file_path: &PathBuf,
        source_text: &str,
    ) -> Result<(), ResolverError> {
        match type_spec {
            TypeSpec::Simple(type_name, _) => {
                // Handle built-in types and user-defined types (structs/enums)
                match type_name.as_str() {
                    "String" => {
                        if !matches!(value.kind, MonValueKind::String(_)) {
                            return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                                field_name: field_name.to_string(),
                                expected_type: "String".to_string(),
                                found_type: format!("{:?}", value.kind),
                                src: Arc::from(NamedSource::new(
                                    file_path.to_string_lossy(),
                                    source_text.to_string(),
                                )),
                                span: (value.pos_start, value.pos_end - value.pos_start).into(),
                            }));
                        }
                    }
                    "Number" => {
                        if !matches!(value.kind, MonValueKind::Number(_)) {
                            return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                                field_name: field_name.to_string(),
                                expected_type: "Number".to_string(),
                                found_type: format!("{:?}", value.kind),
                                src: Arc::from(NamedSource::new(
                                    file_path.to_string_lossy(),
                                    source_text.to_string(),
                                )),
                                span: (value.pos_start, value.pos_end - value.pos_start).into(),
                            }));
                        }
                    }
                    "Boolean" => {
                        if !matches!(value.kind, MonValueKind::Boolean(_)) {
                            return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                                field_name: field_name.to_string(),
                                expected_type: "Boolean".to_string(),
                                found_type: format!("{:?}", value.kind),
                                src: Arc::from(NamedSource::new(
                                    file_path.to_string_lossy(),
                                    source_text.to_string(),
                                )),
                                span: (value.pos_start, value.pos_end - value.pos_start).into(),
                            }));
                        }
                    }
                    "Null" => {
                        if !matches!(value.kind, MonValueKind::Null) {
                            return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                                field_name: field_name.to_string(),
                                expected_type: "Null".to_string(),
                                found_type: format!("{:?}", value.kind),
                                src: Arc::from(NamedSource::new(
                                    file_path.to_string_lossy(),
                                    source_text.to_string(),
                                )),
                                span: (value.pos_start, value.pos_end - value.pos_start).into(),
                            }));
                        }
                    }
                    "Object" => {
                        if !matches!(value.kind, MonValueKind::Object(_)) {
                            return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                                field_name: field_name.to_string(),
                                expected_type: "Object".to_string(),
                                found_type: format!("{:?}", value.kind),
                                src: Arc::from(NamedSource::new(
                                    file_path.to_string_lossy(),
                                    source_text.to_string(),
                                )),
                                span: (value.pos_start, value.pos_end - value.pos_start).into(),
                            }));
                        }
                    }
                    "Array" => {
                        if !matches!(value.kind, MonValueKind::Array(_)) {
                            return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                                field_name: field_name.to_string(),
                                expected_type: "Array".to_string(),
                                found_type: format!("{:?}", value.kind),
                                src: Arc::from(NamedSource::new(
                                    file_path.to_string_lossy(),
                                    source_text.to_string(),
                                )),
                                span: (value.pos_start, value.pos_end - value.pos_start).into(),
                            }));
                        }
                    }
                    "Any" => { /* Always valid, like you :D */ }
                    _ => {
                        // User-defined type (Struct or Enum)
                        let (namespace, type_name_part) =
                            if let Some((ns, tn)) = type_name.split_once('.') {
                                (Some(ns), tn)
                            } else {
                                (None, type_name.as_str())
                            };

                        let type_def = if let Some(namespace) = namespace {
                            // Find the import statement for this namespace
                            let import_statement = imports
                                .iter()
                                .find(|i| {
                                    if let ImportSpec::Namespace(ns) = &i.spec {
                                        ns == namespace
                                    } else {
                                        false
                                    }
                                })
                                .ok_or_else(|| {
                                    ResolverError::Validation(ValidationError::UndefinedType {
                                        type_name: type_name.clone(),
                                        src: Arc::from(NamedSource::new(
                                            file_path.to_string_lossy(),
                                            source_text.to_string(),
                                        )),
                                        span: (value.pos_start, value.pos_end - value.pos_start)
                                            .into(),
                                    })
                                })?;

                            let imported_path_str = import_statement.path.trim_matches('"');
                            let parent_dir = file_path.parent().ok_or_else(|| {
                                // This case is unlikely but good to handle.
                                // It means the file path is something like "/" or "C:\"
                                ResolverError::ModuleNotFound {
                                    path: import_statement.path.clone(),
                                    src: Arc::from(NamedSource::new(
                                        file_path.to_string_lossy(),
                                        source_text.to_string(),
                                    )),
                                    span: (
                                        import_statement.pos_start,
                                        import_statement.pos_end - import_statement.pos_start,
                                    )
                                        .into(),
                                }
                            })?;
                            let absolute_imported_path = parent_dir.join(imported_path_str);

                            let imported_doc = self
                                .resolved_documents
                                .get(&absolute_imported_path)
                                .ok_or_else(|| {
                                    // This indicates a logic error in the resolver, as the document
                                    // should have been resolved and stored during the initial import pass.
                                    ResolverError::ModuleNotFound {
                                        path: absolute_imported_path.to_string_lossy().to_string(),
                                        src: Arc::from(NamedSource::new(
                                            file_path.to_string_lossy(),
                                            source_text.to_string(),
                                        )),
                                        span: (value.pos_start, value.pos_end - value.pos_start)
                                            .into(),
                                    }
                                })?;

                            if let MonValueKind::Object(members) = &imported_doc.root.kind {
                                members.iter().find_map(|m| {
                                    if let Member::TypeDefinition(td) = m {
                                        if td.name == type_name_part {
                                            return Some(td.def_type.clone());
                                        }
                                    }
                                    None
                                })
                            } else {
                                None
                            }
                        } else {
                            self.symbol_table
                                .types
                                .get(type_name_part)
                                .map(|td| td.def_type.clone())
                        };

                        if let Some(type_def) = type_def {
                            match type_def {
                                TypeDef::Struct(struct_def) => {
                                    // Validate against struct
                                    if let MonValueKind::Object(value_members) = &mut value.kind {
                                        let mut value_map: HashMap<String, &mut MonValue> =
                                            HashMap::new();
                                        for member in value_members.iter_mut() {
                                            if let Member::Pair(pair) = member {
                                                value_map.insert(pair.key.clone(), &mut pair.value);
                                            }
                                        }

                                        let mut new_members = Vec::new();
                                        for field_def in &struct_def.fields {
                                            if let Some(field_value) = value_map.get_mut(&field_def.name) {
                                                // Field exists, validate its type
                                                self.validate_value(
                                                    field_value,
                                                    &field_def.type_spec,
                                                    &field_def.name,
                                                    imports, // Pass the imports here
                                                    file_path,
                                                    source_text,
                                                )?;
                                            } else {
                                                // Field missing
                                                if field_def.default_value.is_none() {
                                                    return Err(ResolverError::Validation(
                                                        ValidationError::MissingField {
                                                            field_name: field_def.name.clone(),
                                                            struct_name: type_name.clone(),
                                                            src: Arc::from(NamedSource::new(
                                                                file_path.to_string_lossy(),
                                                                source_text.to_string(),
                                                            )),
                                                            span: (
                                                                value.pos_start,
                                                                value.pos_end - value.pos_start,
                                                            )
                                                                .into(),
                                                        },
                                                    ));
                                                }
                                                // Field is missing, but has a default value.
                                                // We need to insert it into the object.
                                                if let Some(default_value) =
                                                    &field_def.default_value
                                                {
                                                    new_members.push(Member::Pair(
                                                        crate::ast::Pair {
                                                            key: field_def.name.clone(),
                                                            value: default_value.clone(),
                                                            validation: None,
                                                        },
                                                    ));
                                                }
                                            }
                                        }
                                        value_members.extend(new_members);

                                        // Check for extra fields
                                        for member in value_members.iter() {
                                            if let Member::Pair(pair) = member {
                                                if !struct_def
                                                    .fields
                                                    .iter()
                                                    .any(|f| f.name == pair.key)
                                                {
                                                    return Err(ResolverError::Validation(
                                                        ValidationError::UnexpectedField {
                                                            field_name: pair.key.clone(),
                                                            struct_name: type_name.clone(),
                                                            src: Arc::from(NamedSource::new(
                                                                file_path.to_string_lossy(),
                                                                source_text.to_string(),
                                                            )),
                                                            span: (
                                                                value.pos_start,
                                                                value.pos_end - value.pos_start,
                                                            )
                                                                .into(),
                                                        },
                                                    ));
                                                }
                                            }
                                        }
                                    } else {
                                        return Err(ResolverError::Validation(
                                            ValidationError::TypeMismatch {
                                                field_name: field_name.to_string(),
                                                expected_type: type_name.clone(),
                                                found_type: format!("{:?}", value.kind),
                                                src: Arc::from(NamedSource::new(
                                                    file_path.to_string_lossy(),
                                                    source_text.to_string(),
                                                )),
                                                span: (
                                                    value.pos_start,
                                                    value.pos_end - value.pos_start,
                                                )
                                                    .into(),
                                            },
                                        ));
                                    }
                                }
                                TypeDef::Enum(enum_def) => {
                                    // Validate against enum
                                    if let MonValueKind::EnumValue {
                                        enum_name,
                                        variant_name,
                                    } = &value.kind {
                                        if enum_name != type_name {
                                            return Err(ResolverError::Validation(
                                                ValidationError::TypeMismatch {
                                                    field_name: field_name.to_string(),
                                                    expected_type: format!("enum {}", type_name),
                                                    found_type: format!("enum {}", enum_name),
                                                    src: Arc::from(NamedSource::new(
                                                        file_path.to_string_lossy(),
                                                        source_text.to_string(),
                                                    )),
                                                    span: (
                                                        value.pos_start,
                                                        value.pos_end - value.pos_start,
                                                    )
                                                        .into(),
                                                },
                                            ));
                                        }
                                        if !enum_def.variants.contains(variant_name) {
                                            return Err(ResolverError::Validation(
                                                ValidationError::UndefinedEnumVariant {
                                                    variant_name: variant_name.clone(),
                                                    enum_name: type_name.clone(),
                                                    src: Arc::from(NamedSource::new(
                                                        file_path.to_string_lossy(),
                                                        source_text.to_string(),
                                                    )),
                                                    span: (
                                                        value.pos_start,
                                                        value.pos_end - value.pos_start,
                                                    )
                                                        .into(),
                                                },
                                            ));
                                        }
                                    } else {
                                        return Err(ResolverError::Validation(
                                            ValidationError::TypeMismatch {
                                                field_name: field_name.to_string(),
                                                expected_type: format!("enum {}", type_name),
                                                found_type: format!("{:?}", value.kind),
                                                src: Arc::from(NamedSource::new(
                                                    file_path.to_string_lossy(),
                                                    source_text.to_string(),
                                                )),
                                                span: (
                                                    value.pos_start,
                                                    value.pos_end - value.pos_start,
                                                )
                                                    .into(),
                                            },
                                        ));
                                    }
                                }
                            }
                        } else {
                            return Err(ResolverError::Validation(
                                ValidationError::UndefinedType {
                                    type_name: type_name.clone(),
                                    src: Arc::from(NamedSource::new(
                                        file_path.to_string_lossy(),
                                        source_text.to_string(),
                                    )),
                                    span: (value.pos_start, value.pos_end - value.pos_start).into(),
                                },
                            ));
                        }
                    }
                }
            }
            TypeSpec::Collection(collection_types, _) => {
                // Handle array validation
                if let MonValueKind::Array(elements) = &mut value.kind {
                    self.validate_collection(
                        elements,
                        collection_types,
                        field_name,
                        imports, // Pass the imports here
                        file_path,
                        source_text,
                    )?;
                } else {
                    return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                        field_name: field_name.to_string(),
                        expected_type: "Array".to_string(),
                        found_type: format!("{:?}", value.kind),
                        src: Arc::from(NamedSource::new(
                            file_path.to_string_lossy(),
                            source_text.to_string(),
                        )),
                        span: (value.pos_start, value.pos_end - value.pos_start).into(),
                    }));
                }
            }
            TypeSpec::Spread(_, _) => {
                // Spread types are handled during parsing/resolution, not validation directly
                return Ok(())
            }
        }
        Ok(())
    }

    /// Validates the elements of an array against a slice of collection `TypeSpec`s.
    fn validate_collection(
        &mut self,
        elements: &mut [MonValue],
        collection_types: &[TypeSpec],
        field_name: &str,
        imports: &[ImportStatement], // Change this parameter
        file_path: &PathBuf,
        source_text: &str,
    ) -> Result<(), ResolverError> {
        // Case 1: [T] - Exactly one element of type T
        if collection_types.len() == 1 && !matches!(collection_types[0], TypeSpec::Spread(_, _)) {
            self.validate_value(
                &mut elements[0],
                &collection_types[0],
                field_name,
                imports, // Pass the imports here
                file_path,
                source_text,
            )?;
            return Ok(())
        }

        // Case 2: [T...] - Zero or more elements of type T
        if collection_types.len() == 1 && matches!(collection_types[0], TypeSpec::Spread(_, _)) {
            if let TypeSpec::Spread(inner_type, _) = &collection_types[0] {
                for element in elements {
                    self.validate_value(
                        element,
                        inner_type,
                        field_name,
                        imports,
                        file_path,
                        source_text,
                    )?;
                }
                return Ok(())
            }
        }

        // Case 3: Tuple-like [T1, T2, ...]
        let has_spread = collection_types
            .iter()
            .any(|t| matches!(t, TypeSpec::Spread(_, _)));
        if !has_spread {
            if elements.len() != collection_types.len() {
                // TODO: Better error for wrong number of elements
                return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                    field_name: field_name.to_string(),
                    expected_type: format!("tuple with {} elements", collection_types.len()),
                    found_type: format!("tuple with {} elements", elements.len()),
                    src: Arc::from(NamedSource::new(
                        file_path.to_string_lossy(),
                        source_text.to_string(),
                    )),
                    span: (
                        elements.first().map_or(0, |e| e.pos_start),
                        elements.last().map_or(0, |e| e.pos_end)
                            - elements.first().map_or(0, |e| e.pos_start),
                    )
                        .into(),
                }));
            }
            for (i, element) in elements.iter_mut().enumerate() {
                self.validate_value(
                    element,
                    &collection_types[i],
                    field_name,
                    imports, // Pass the imports here
                    file_path,
                    source_text,
                )?;
            }
            return Ok(())
        }

        // Case 4: [T1, T2...] - One or more elements, first is T1, rest are T2
        if collection_types.len() == 2
            && !matches!(collection_types[0], TypeSpec::Spread(_, _))
            && matches!(collection_types[1], TypeSpec::Spread(_, _)) {
            if elements.is_empty() {
                return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                    field_name: field_name.to_string(),
                    expected_type: "array with at least 1 element".to_string(),
                    found_type: "empty array".to_string(),
                    src: Arc::from(NamedSource::new(
                        file_path.to_string_lossy(),
                        source_text.to_string(),
                    )),
                    span: (
                        elements.first().map_or(0, |e| e.pos_start),
                        elements.last().map_or(0, |e| e.pos_end)
                            - elements.first().map_or(0, |e| e.pos_start),
                    )
                        .into(),
                }));
            }
            self.validate_value(
                &mut elements[0],
                &collection_types[0],
                field_name,
                imports, // Pass the imports here
                file_path,
                source_text,
            )?;
            if let TypeSpec::Spread(inner_type, _) = &collection_types[1] {
                for element in &mut elements[1..] {
                    self.validate_value(
                        element,
                        inner_type,
                        field_name,
                        imports,
                        file_path,
                        source_text,
                    )?;
                }
            }
            return Ok(())
        }

        // Case 5: [T1..., T2] - One or more elements, last is T2, rest are T1
        if collection_types.len() == 2
            && matches!(collection_types[0], TypeSpec::Spread(_, _))
            && !matches!(collection_types[1], TypeSpec::Spread(_, _)) {
            if elements.is_empty() {
                return Err(ResolverError::Validation(ValidationError::TypeMismatch {
                    field_name: field_name.to_string(),
                    expected_type: "array with at least 1 element".to_string(),
                    found_type: "empty array".to_string(),
                    src: Arc::from(NamedSource::new(
                        file_path.to_string_lossy(),
                        source_text.to_string(),
                    )),
                    span: (
                        elements.first().map_or(0, |e| e.pos_start),
                        elements.last().map_or(0, |e| e.pos_end)
                            - elements.first().map_or(0, |e| e.pos_start),
                    )
                        .into(),
                }));
            }
            let (head, last) = elements.split_at_mut(elements.len() - 1);
            self.validate_value(
                last.first_mut().unwrap(), // Get the last element
                &collection_types[1],
                field_name,
                imports, // Pass the imports here
                file_path,
                source_text,
            )?;
            if let TypeSpec::Spread(inner_type, _) = &collection_types[0] {
                for element in head {
                    self.validate_value(
                        element,
                        inner_type,
                        field_name,
                        imports,
                        file_path,
                        source_text,
                    )?;
                }
            }
            return Ok(())
        }

        // If none of the specific cases match, it's an unimplemented complex collection type
        Err(ResolverError::Validation(
            ValidationError::UnimplementedCollectionValidation {
                field_name: field_name.to_string(),
                src: Arc::from(NamedSource::new(
                    file_path.to_string_lossy(),
                    source_text.to_string(),
                )),
                span: (
                    elements.first().map_or(0, |e| e.pos_start),
                    elements.last().map_or(0, |e| e.pos_end)
                        - elements.first().map_or(0, |e| e.pos_start),
                )
                    .into(),
            },
        ))
    }
}

impl Default for Resolver {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use crate::parser::Parser;
    use crate::resolver::Resolver;
    use miette::Report;
    use std::fs;
    use std::path::{Path, PathBuf};

    fn resolve_ok(source: &str, file_name: &str) -> crate::ast::MonDocument {
        let mut parser = Parser::new_with_name(source, file_name.to_string()).unwrap();
        let document = parser.parse_document().unwrap();
        let mut resolver = Resolver::new();
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.push(file_name);
        match resolver.resolve(document, source, path, None) {
            Ok(doc) => doc,
            Err(err) => {
                let report = Report::from(err);
                panic!("{report:#}");
            }
        }
    }

    fn resolve_err(source: &str, file_name: &str) -> crate::error::ResolverError {
        let mut parser = Parser::new_with_name(source, file_name.to_string()).unwrap();
        let document = parser.parse_document().unwrap();
        let mut resolver = Resolver::new();
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.push(file_name);
        match resolver.resolve(document, source, path, None) {
            Ok(_) => panic!("Expected a ResolverError, but got Ok"),
            Err(err) => err,
        }
    }

    #[test]
    fn test_simple_alias_resolution() {
        let source = r"{ &my_value: 123, alias_value: *my_value }";
        let doc = resolve_ok(source, "test.mon");

        let root_object = match doc.root.kind {
            crate::ast::MonValueKind::Object(members) => members,
            _ => panic!("Expected an object"),
        };

        // Check that the alias_value is resolved to 123
        let alias_member = root_object
            .iter()
            .find(|m| {
                if let crate::ast::Member::Pair(p) = m {
                    p.key == "alias_value"
                } else {
                    false
                }
            })
            .unwrap();

        if let crate::ast::Member::Pair(p) = alias_member {
            assert_eq!(p.value.kind, crate::ast::MonValueKind::Number(123.0));
        } else {
            panic!("Expected a pair member");
        }
    }

    #[test]
    fn test_object_spread_resolution() {
        let source = r#"{ 
        &base_config: { host: "localhost", port: 8080 },
        app_config: {
            ...*base_config,
            port: 9000, // Override
            debug: true,
        }
    }"#;
        let doc = resolve_ok(source, "test.mon");

        let root_object = match doc.root.kind {
            crate::ast::MonValueKind::Object(members) => members,
            _ => panic!("Expected an object"),
        };

        let app_config_member = root_object
            .iter()
            .find(|m| {
                if let crate::ast::Member::Pair(p) = m {
                    p.key == "app_config"
                } else {
                    false
                }
            })
            .unwrap();

        if let crate::ast::Member::Pair(p) = app_config_member {
            let app_config_object = match &p.value.kind {
                crate::ast::MonValueKind::Object(members) => members,
                _ => panic!("Expected app_config to be an object"),
            };

            // Check host
            let host_member = app_config_object
                .iter()
                .find(|m| {
                    if let crate::ast::Member::Pair(p) = m {
                        p.key == "host"
                    } else {
                        false
                    }
                })
                .unwrap();
            if let crate::ast::Member::Pair(p) = host_member {
                assert_eq!(
                    p.value.kind,
                    crate::ast::MonValueKind::String("localhost".to_string())
                );
            } else {
                panic!("Expected host to be a pair");
            }

            // Check port (overridden)
            let port_member = app_config_object
                .iter()
                .find(|m| {
                    if let crate::ast::Member::Pair(p) = m {
                        p.key == "port"
                    } else {
                        false
                    }
                })
                .unwrap();
            if let crate::ast::Member::Pair(p) = port_member {
                assert_eq!(p.value.kind, crate::ast::MonValueKind::Number(9000.0));
            } else {
                panic!("Expected port to be a pair");
            }

            // Check debug (new field)
            let debug_member = app_config_object
                .iter()
                .find(|m| {
                    if let crate::ast::Member::Pair(p) = m {
                        p.key == "debug"
                    } else {
                        false
                    }
                })
                .unwrap();
            if let crate::ast::Member::Pair(p) = debug_member {
                assert_eq!(p.value.kind, crate::ast::MonValueKind::Boolean(true));
            } else {
                panic!("Expected debug to be a pair");
            }
        } else {
            panic!("Expected app_config to be a pair member");
        }
    }

    #[test]
    fn test_array_spread_resolution() {
        let source = r#"{
        &base_tags: ["tag1", "tag2"],
        item_tags: [
            "start",
            ...*base_tags,
            "end",
        ]
    }"#;
        let doc = resolve_ok(source, "test.mon");

        let root_object = match doc.root.kind {
            crate::ast::MonValueKind::Object(members) => members,
            _ => panic!("Expected an object"),
        };

        let item_tags_member = root_object
            .iter()
            .find(|m| {
                if let crate::ast::Member::Pair(p) = m {
                    p.key == "item_tags"
                } else {
                    false
                }
            })
            .unwrap();

        if let crate::ast::Member::Pair(p) = item_tags_member {
            let item_tags_array = match &p.value.kind {
                crate::ast::MonValueKind::Array(elements) => elements,
                _ => panic!("Expected item_tags to be an array"),
            };

            assert_eq!(item_tags_array.len(), 4);
            assert_eq!(
                item_tags_array[0].kind,
                crate::ast::MonValueKind::String("start".to_string())
            );
            assert_eq!(
                item_tags_array[1].kind,
                crate::ast::MonValueKind::String("tag1".to_string())
            );
            assert_eq!(
                item_tags_array[2].kind,
                crate::ast::MonValueKind::String("tag2".to_string())
            );
            assert_eq!(
                item_tags_array[3].kind,
                crate::ast::MonValueKind::String("end".to_string())
            );
        } else {
            panic!("Expected item_tags to be a pair member");
        }
    }

    #[test]
    fn test_struct_validation_with_defaults_and_collections_ok() {
        let source = r###"
        {
            User: #struct {
                id(Number),
                name(String),
                email(String) = "default@example.com",
                is_active(Boolean) = true,
                roles([String...]),
                permissions([String, Number]),
                log_data([String, Any...]),
                status_history([Boolean..., String]),
            },

            // Valid user with defaults
            user1 :: User = {
                id: 1,
                name: "Alice",
                roles: ["admin", "editor"],
                permissions: ["read", 1],
                log_data: ["login", { timestamp: "...", ip: "..." }],
                status_history: [true, false, "active"],
            },

            // Valid user, omitting optional fields
            user2 :: User = {
                id: 2,
                name: "Bob",
                roles: [],
                permissions: ["write", 2],
                log_data: ["logout"],
                status_history: ["inactive"],
            },
        }
    "###;

        // Test valid user1
        let doc = resolve_ok(source, "test_validation.mon");
        let root_object = match doc.root.kind {
            crate::ast::MonValueKind::Object(members) => members,
            _ => panic!("Expected an object"),
        };

        let user1_member = root_object
            .iter()
            .find(|m| {
                if let crate::ast::Member::Pair(p) = m {
                    p.key == "user1"
                } else {
                    false
                }
            })
            .unwrap();

        if let crate::ast::Member::Pair(p) = user1_member {
            let user1_object = match &p.value.kind {
                crate::ast::MonValueKind::Object(members) => members,
                _ => panic!("Expected user1 to be an object"),
            };

            // Check default email
            let email_member = user1_object
                .iter()
                .find(|m| {
                    if let crate::ast::Member::Pair(p) = m {
                        p.key == "email"
                    } else {
                        false
                    }
                })
                .unwrap();
            if let crate::ast::Member::Pair(p) = email_member {
                assert_eq!(
                    p.value.kind,
                    crate::ast::MonValueKind::String("default@example.com".to_string())
                );
            } else {
                panic!("Expected email to be a pair");
            }

            // Check default is_active
            let is_active_member = user1_object
                .iter()
                .find(|m| {
                    if let crate::ast::Member::Pair(p) = m {
                        p.key == "is_active"
                    } else {
                        false
                    }
                })
                .unwrap();
            if let crate::ast::Member::Pair(p) = is_active_member {
                assert_eq!(p.value.kind, crate::ast::MonValueKind::Boolean(true));
            } else {
                panic!("Expected is_active to be a pair");
            }
        } else {
            panic!("Expected user1 to be a pair member");
        }
    }

    #[test]
    fn test_struct_validation_missing_required_field() {
        let source = r###"
        {
            User: #struct { id(Number), name(String) },
            invalid_user :: User = { id: 3 },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::MissingField { field_name, .. },
            ) => {
                assert_eq!(field_name, "name");
            }
            _ => panic!("Expected MissingField error, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_wrong_id_type() {
        let source = r###"
        {
            User: #struct { id(Number), name(String) },
            invalid_user :: User = { id: "four", name: "Charlie" },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "id");
                assert_eq!(expected_type, "Number");
                assert!(found_type.contains("String"));
            }
            _ => panic!("Expected TypeMismatch error for id, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_unexpected_field() {
        let source = r###"
        {
            User: #struct { id(Number), name(String) },
            invalid_user :: User = { id: 5, name: "David", age: 30 },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::UnexpectedField { field_name, .. },
            ) => {
                assert_eq!(field_name, "age");
            }
            _ => panic!("Expected UnexpectedField error, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_roles_type_mismatch() {
        let source = r###"
        {
            User: #struct { roles([String...]) },
            invalid_user :: User = { roles: ["viewer", 123] },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "roles");
                assert_eq!(expected_type, "String");
                assert!(found_type.contains("Number"));
            }
            _ => panic!("Expected TypeMismatch error for roles, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_permissions_length_mismatch() {
        let source = r###"
        {
            User: #struct { permissions([String, Number]) },
            invalid_user :: User = { permissions: ["read"] },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "permissions");
                assert!(expected_type.contains("tuple with 2 elements"));
                assert!(found_type.contains("tuple with 1 elements"));
            }
            _ => panic!("Expected TypeMismatch error for permissions length, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_permissions_type_mismatch() {
        let source = r###"
        {
            User: #struct { permissions([String, Number]) },
            invalid_user :: User = { permissions: [8, "write"] },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "permissions");
                assert_eq!(expected_type, "String");
                assert!(found_type.contains("Number"));
            }
            _ => panic!("Expected TypeMismatch error for permissions types, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_log_data_first_type_mismatch() {
        let source = r###"
        {
            User: #struct { log_data([String, Any...]) },
            invalid_user :: User = { log_data: [123, "event"] },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "log_data");
                assert_eq!(expected_type, "String");
                assert!(found_type.contains("Number"));
            }
            _ => panic!("Expected TypeMismatch error for log_data first type, but got {err:?}"),
        }
    }

    #[test]
    fn test_struct_validation_status_history_last_type_mismatch() {
        let source = r###"
        {
            User: #struct { status_history([Boolean..., String]) },
            invalid_user :: User = { status_history: [true, 123] },
        }
    "###;
        let err = resolve_err(source, "test_validation.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "status_history");
                assert_eq!(expected_type, "String");
                assert!(found_type.contains("Number"));
            }
            _ => {
                panic!("Expected TypeMismatch error for status_history last type, but got {err:?}")
            }
        }
    }

    #[test]
    fn test_nested_struct_validation_ok() {
        let source = r###"
        {
            Profile: #struct {
                username(String),
                email(String),
            },
            User: #struct {
                id(Number),
                profile(Profile),
            },

            // Valid nested struct
            user1 :: User = {
                id: 1,
                profile: {
                    username: "alice",
                    email: "alice@example.com",
                },
            },
        }
    "###;

        resolve_ok(source, "test_nested_ok.mon");
    }

    #[test]
    fn test_nested_struct_validation_err() {
        let source = r###"
        {
            Profile: #struct {
                username(String),
                email(String),
            },
            User: #struct {
                id(Number),
                profile(Profile),
            },

            // Invalid: Nested struct has wrong type for username
            user2 :: User = {
                id: 2,
                profile: {
                    username: 123,
                    email: "bob@example.com",
                },
            },
        }
    "###;

        let err = resolve_err(source, "test_nested_err.mon");
        match err {
            crate::error::ResolverError::Validation(
                crate::error::ValidationError::TypeMismatch {
                    field_name,
                    expected_type,
                    found_type,
                    .. 
                },
            ) => {
                assert_eq!(field_name, "username");
                assert_eq!(expected_type, "String");
                assert!(found_type.contains("Number"));
            }
            _ => panic!("Expected TypeMismatch error for username, but got {err:?}"),
        }
    }

    #[test]
    fn test_cross_file_validation() {
        let source = fs::read_to_string("tests/cross_file_main.mon").unwrap();
        resolve_ok(&source, "tests/cross_file_main.mon");
    }

    #[test]
    fn test_parser_for_schemas_file() {
        let source = fs::read_to_string("tests/cross_file_schemas.mon").unwrap();
        let mut parser = Parser::new_with_name(&source, "test.mon".to_string()).unwrap();
        let _ = parser.parse_document().unwrap();
    }

    #[test]
    fn test_named_import_validation() {
        let source = fs::read_to_string("tests/named_import_main.mon").unwrap();
        resolve_ok(&source, "tests/named_import_main.mon");
    }

    use super::*;
    use tempfile::TempDir;
    // Helper to create a test resolver with a custom builtin path
    fn test_resolver_with_builtin(builtin_path: PathBuf) -> Resolver {
        Resolver::with_builtin_path(builtin_path)
    }
    // Helper to create test files
    fn create_test_file(dir: &Path, name: &str, content: &str) -> PathBuf {
        let path = dir.join(name);
        fs::write(&path, content).unwrap();
        path
    }
    #[test]
    fn test_mon_uri_resolution() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");
        fs::create_dir_all(builtin_path.join("types")).unwrap();
        // Create a builtin schema file
        create_test_file(
            &builtin_path.join("types"),
            "linter.mon",
            r#"{ 
                LintConfig: #struct {
                    max_depth(Number) = 5
                }
            }"#, 
        );
        let resolver = test_resolver_with_builtin(builtin_path.clone());
        // Test mon: URI resolution
        let resolved = resolver.resolve_import_path("mon:types/linter", Path::new("."));
        assert_eq!(resolved, builtin_path.join("types/linter.mon"));
    }
    #[test]
    fn test_relative_path_unchanged() {
        let resolver = Resolver::new();
        let current_dir = Path::new("/project/src");
        // Relative paths should be resolved relative to current_dir
        let resolved = resolver.resolve_import_path("./config.mon", current_dir);
        assert_eq!(resolved, PathBuf::from("/project/src/./config.mon"));
        let resolved = resolver.resolve_import_path("../shared/types.mon", current_dir);
        assert_eq!(resolved, PathBuf::from("/project/src/../shared/types.mon"));
    }
    #[test]
    fn test_absolute_path_preserved() {
        let resolver = Resolver::new();
        let current_dir = Path::new("/project");
        let resolved = resolver.resolve_import_path("/usr/share/schemas/common.mon", current_dir);
        assert_eq!(resolved, PathBuf::from("/usr/share/schemas/common.mon"));
    }
    #[test]
    fn test_mon_uri_nested_paths() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");
        fs::create_dir_all(builtin_path.join("types/database")).unwrap();
        let resolver = test_resolver_with_builtin(builtin_path.clone());
        // Test deeply nested paths
        let resolved = resolver.resolve_import_path("mon:types/database/postgres", Path::new("."));
        assert_eq!(resolved, builtin_path.join("types/database/postgres.mon"));
    }
    #[test]
    fn test_mon_uri_with_full_resolution() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");
        fs::create_dir_all(builtin_path.join("types")).unwrap();
        // Create builtin schema
        let schema_content = r#"{ 
            TestType: #struct {
                field(String)
            }
        }"#;
        create_test_file(&builtin_path.join("types"), "test.mon", schema_content);
        // Create main file that imports from mon:
        let main_content = r###"
            import { TestType } from "mon:types/test"

            {
                value :: TestType = { field: "hello" }
            }
        "###;
        let main_path = create_test_file(temp_dir.path(), "main.mon", main_content);
        // Parse and resolve
        let mut parser = crate::parser::Parser::new_with_name(
            main_content,
            main_path.to_string_lossy().to_string(),
        )
        .unwrap();
        let doc = parser.parse_document().unwrap();
        let mut resolver = test_resolver_with_builtin(builtin_path);
        let result = resolver.resolve(doc, main_content, main_path.clone(), None);
        assert!(result.is_ok(), "Resolution should succeed");

        // Verify the imported type is in the symbol table
        assert!(resolver.symbol_table.types.contains_key("TestType"));
    }
    #[test]
    fn test_mixed_imports() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");
        fs::create_dir_all(builtin_path.join("types")).unwrap();
        // Create builtin schema
        create_test_file(
            &builtin_path.join("types"),
            "builtin.mon",
            r#"{ BuiltinType: #struct { id(Number) } }"#,
        );
        // Create local schema
        create_test_file(
            temp_dir.path(),
            "local.mon",
            r#"{ LocalType: #struct { name(String) } }"#,
        );
        // Create main file with both imports
        let main_content = r###"
            import { BuiltinType } from "mon:types/builtin"
            import { LocalType } from "./local.mon"

            {
                builtin :: BuiltinType = { id: 1 },
                local :: LocalType = { name: "test" }
            }
        "###;
        let main_path = create_test_file(temp_dir.path(), "main.mon", main_content);
        let mut parser = crate::parser::Parser::new_with_name(
            main_content,
            main_path.to_string_lossy().to_string(),
        )
        .unwrap();
        let doc = parser.parse_document().unwrap();
        let mut resolver = test_resolver_with_builtin(builtin_path);
        let result = resolver.resolve(doc, main_content, main_path, None);
        assert!(result.is_ok());
        assert!(resolver.symbol_table.types.contains_key("BuiltinType"));
        assert!(resolver.symbol_table.types.contains_key("LocalType"));
    }
    #[test]
    fn test_mon_uri_not_found() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");
        fs::create_dir_all(&builtin_path).unwrap();
        let main_content = r###"
            import { Missing } from "mon:types/nonexistent"
            {}
        "###;
        let main_path = create_test_file(temp_dir.path(), "main.mon", main_content);
        let mut parser = crate::parser::Parser::new_with_name(
            main_content,
            main_path.to_string_lossy().to_string(),
        )
        .unwrap();
        let doc = parser.parse_document().unwrap();
        let mut resolver = test_resolver_with_builtin(builtin_path);
        let result = resolver.resolve(doc, main_content, main_path, None);
        assert!(matches!(result, Err(ResolverError::ModuleNotFound { .. })))
    }
    #[test]
    fn test_default_builtin_path() {
        // Test that default_builtin_path doesn't panic
        let path = Resolver::default_builtin_path();
        assert!(path.is_absolute() || path == Path::new("."));
    }
    #[test]
    fn test_mon_uri_auto_adds_extension() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");

        let resolver = test_resolver_with_builtin(builtin_path.clone());
        // Should add .mon extension
        let resolved = resolver.resolve_import_path("mon:config/app", Path::new("."));
        assert_eq!(resolved, builtin_path.join("config/app.mon"));
        assert!(resolved.to_string_lossy().ends_with(".mon"));
    }
    #[test]
    fn test_environment_variable_override() {
        // Set environment variable
        std::env::set_var("MON_BUILTIN_PATH", "/custom/builtin/path");

        let path = Resolver::default_builtin_path();

        // Clean up
        std::env::remove_var("MON_BUILTIN_PATH");

        assert_eq!(path, PathBuf::from("/custom/builtin/path"));
    }
    #[test]
    fn test_circular_dependency_with_mon_imports() {
        let temp_dir = TempDir::new().unwrap();
        let builtin_path = temp_dir.path().join("schemas");
        fs::create_dir_all(&builtin_path).unwrap();
        // Create circular dependency: a.mon -> b.mon -> a.mon
        create_test_file(
            &builtin_path,
            "a.mon",
            r###"import { B } from "mon:b" { A: #struct { b(B) } }"###,
        );
        create_test_file(
            &builtin_path,
            "b.mon",
            r###"import { A } from "mon:a" { B: #struct { a(A) } }"###,
        );
        let main_content = r###"import { A } from "mon:a" {}"###;
        let main_path = create_test_file(temp_dir.path(), "main.mon", main_content);
        let mut parser = crate::parser::Parser::new_with_name(
            main_content,
            main_path.to_string_lossy().to_string(),
        )
        .unwrap();
        let doc = parser.parse_document().unwrap();
        let mut resolver = test_resolver_with_builtin(builtin_path);
        let result = resolver.resolve(doc, main_content, main_path, None);
        assert!(matches!(
            result,
            Err(ResolverError::CircularDependency { .. })
        ));
    }
}